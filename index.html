<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Skynet : Skynet is a framework for distributed services in Go." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Skynet</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bketelsen/skynet">View on GitHub</a>

          <h1 id="project_title">Skynet</h1>
          <h2 id="project_tagline">Skynet is a framework for distributed services in Go.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/bketelsen/skynet/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/bketelsen/skynet/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><img src="/bketelsen/skynet/raw/master/documentation/SkyNetLogo.png" alt="logo"></p>

<h2>Introduction</h2>

<p>Skynet is a communication protocol for building massively distributed apps in Go.  It is not constrained to Go, so it will lend itself nicely to polyglot environments.</p>

<h2>Tell me more:</h2>

<p>Servers die, stop communicating, catch on fire, get killed by robots from the future, and should not be trusted. If your site won’t work with a Chaos Monkey, it isn’t safe. Enter Skynet. Each Skynet module is self–contained, self–aware, and self–replicating – if you have one server with an authentication module on it, and that server melts, Skynet will notice, kill it, and automatically create a new one. (if you let it)</p>

<p>Skynet probably won’t die unless your data center gets hit by a comet.  We recommend at least 2 data centers in that scenario.</p>

<p>Skynet Services are where the work gets done.  These are the processes that service the requests, process the API calls, get the external data, log the requests, authenticate the users, etc. </p>

<p>Before you can run skynet you'll need to have at least one <a href="https://github.com/ha/doozerd">doozer</a> process running.  </p>

<h2>How?</h2>

<p>Each process in SkyNet receives its configuration from a centralized configuration repository (currently Doozer - possibly pluggable in the future).  Configuration changes are pushed to each process when new skynet services are started.  This means that starting a new service automatically
advertises that service's availability to the rest of the members of the skynet cluster.</p>

<p>SkyNet uses Doozer to store configuration data about the available services.  Configuration changes are pushed to Doozer, causing connected clients to immediately become aware of changed configurations.  </p>

<h2>Running Processes</h2>

<ul>
<li>Sending SIGINT to a running process gracefully exits.</li>
</ul><h6>Work in Progress</h6>

<ul>
<li>Sending SIGUSR1 to a running process raises the log level one notch.</li>
<li>Sending SIGUSR2 to a running process lowers the log level one notch.</li>
</ul><h2>Doozer</h2>

<p>Skynet makes heavy usage of Doozer. Both clients and services will take a DoozerConfig so that it knows how to communicate with doozer. In the examples directory there is a shell script to startup a cluster of doozer instances locally for testing.</p>

<p>We recommend using at least 5 instances of doozer in your cluster, if you have 3, and lose 1, if an additonal doozer instance goes down the doozer cluster doesn't reject it.</p>

<pre>
type DoozerConfig struct {
    Uri          string
    BootUri      string
    AutoDiscover bool
}
</pre>

<ul>
<li>Uri - ip/port of your doozer instance, this can be a comma separated list as well (doozer:8046, 127.0.0.1:8046)</li>
<li>BootUri - If you are using DzNs this is the ip/port of an instance of your boot cluster (doozer:8046, 127.0.0.1:8046)</li>
<li>AutoDiscover - true/false, Should this service or client discover other doozer instances in the doozer cluster, and use them for failback in case it looses it's current connection, as well as monitor any addition/removal from the doozer cluster</li>
</ul><h2>Services</h2>

<p>Services are the heart of your skynet clusters, they will accept requests via msgpack rpc requests. Keep in mind that a Service may also be a client. In the case of a Composite style application, a request could be made to one service that makes requests either synchronously or asynchronously to additional skynet services.</p>

<h5>Sweet! How do I create a service?</h5>

<p>Provided you have a doozer instance setup. It's pretty simple. Just create your service, with any methods you want exposed via rpc, and make sure it implements skylib.ServiceInterface</p>

<pre>
type ServiceInterface interface {
    Started(s *Service)
    Stopped(s *Service)
    Registered(s *Service)
    Unregistered(s *Service)
}
</pre>

<p>Then call skylib.CreateService() passing it, a ServiceConfig, and and pointer to your custom service. Then call:</p>

<pre>
service.Start(true)
</pre>

<p>The boolean flag specifies whether the service should immediately register itself with the cluster.</p>

<pre>
type BindAddr struct {
    IPAddress string
    Port      int
}

type ServiceConfig struct {
    Log         *log.Logger `json:"-"`
    Name        string
    Version     string
    Region      string
    ServiceAddr *BindAddr
    AdminAddr   *BindAddr
    DoozerConfig *DoozerConfig `json:"-"`
}
</pre>

<p>Checkout the examples/service directory for a full example, also a call to skylib.GetServiceConfigFromFlags() will, allow you to get all the config params from flags passed in via the command line.</p>

<h2>Clients</h2>

<p>Clients are just as simple. They start with a ClientConfig:</p>

<h5>Smart Connection Pools</h5>

<p>ServiceClients's contain a pool of connections to a given service, up to a specified size to load balance requests across. Instances are removed from skynet when they crash, the pools are smart enough to remove any connections to any instances that are no longer available and replace them with connections to valid instances to maintain the pool.</p>

<pre>
type ClientConfig struct {
    Log         *log.Logger `json:"-"`
    DoozerConfig *DoozerConfig `json:"-"`
}
</pre>

<p>Then a call to:</p>

<pre>
skylib.GetService(name string, version string, region string, host string) (*ServiceClient)
</pre>

<ul>
<li>name - the name of the service you want to connect to, this is specified in your ServiceConfig</li>
<li>version - the version of the service, in case you have multiple versions up and running for backward compatibility, or you are in the middle of an upgrade / deploy</li>
<li>region - If you only want a connection(s) to instances of this service in a specific region (specified by the service) in case you want to keep a particular request in data center etc.</li>
<li>host - Similar to region, this restricts connections to only the specified host, an example might be if you only want to connect to the host the current client is on.</li>
</ul><p>Any empty values "", are considered to mean any/all instances matching the other supplied criteria.</p>

<p>This call returns a pointer to a ServiceClient, think of this as a connection pool, to instances of the service you requested, matching your criteria. It will always point contain connections to live instances, and readjust itself as the cluster changes, and recover from connection failures.</p>

<p>From here just call your RPC method:</p>

<pre>
serviceClient.Send("echo", "I'm connected!!")
</pre>

<p>Checkout the examples/client. directory for a full example.</p>

<h2>Management</h2>

<p>The "sky" command is your management gateway into the skynet cluster. It will allow you to probe the network and look for services/versions, hosts, regions etc in your cluster. As well as run administration commands to operate on instances that match the criteria (*admin commands are on the way, search functionality is here)</p>

<pre>
Usage:
     sky -option1=value -option2=value command 

Commands:

    cli: Interactive shell for executing commands against skynet cluster
    hosts: List all hosts available that meet the specified criteria
        -service - limit results to hosts running the specified service
        -version - limit results to hosts running the specified version of the service (-service required)
        -region - limit results to hosts in the specified region
    instances: List all instances available that meet the specified criteria
        -service - limit results to instances of the specified service
        -version - limit results to instances of the specified version of service
        -region - limit results to instances in the specified region
        -host - limit results to instances on the specified host
        -registered - (true, false) limit results to instances that are registered (accepting requests)
    regions: List all regions available that meet the specified criteria
    services: List all services available that meet the specified criteria
        -host - limit results to the specified host
        -region - limit results to hosts in the specified region

    versions: List all services available that meet the specified criteria
        -service - service name (required)
        -host - limit results to the specified host
        -region - limit results to hosts in the specified region

    topology: Print detailed heirarchy of regions/hosts/services/versions/instances
        -service - limit results to instances of the specified service
        -version - limit results to instances of the specified version of service
        -region - limit results to instances in the specified region
        -host - limit results to instances on the specified host
</pre>

<h4>Interactive Shell</h4>

<p>Another option is to use the interactive shell "<b>sky cli</b>". Which will open a shell you can interact with. Setting filters will allow any future commands to only apply to resources that meet those conditions.</p>

<pre>
Skynet Interactive Shell
&gt; help

Commands:
    hosts: List all hosts available that meet the specified criteria
    instances: List all instances available that meet the specified criteria
    regions: List all regions available that meet the specified criteria
    services: List all services available that meet the specified criteria
    versions: List all services available that meet the specified criteria
    topology: Print detailed heirarchy of regions/hosts/services/versions/instances

Filters:
    filters - list current filters
    reset &lt;filter&gt; - reset all filters or specified filter
    region &lt;region&gt; - Set region filter, all commands will be scoped to this region until reset
    service &lt;service&gt; - Set service filter, all commands will be scoped to this service until reset
    version &lt;version&gt; - Set version filter, all commands will be scoped to this version until reset
    host &lt;host&gt; - Set host filter, all commands will be scoped to this host until reset
</pre>

<h2>Internals</h2>

<h5>Query</h5>

<p>The sky command and the client connectivity logic is all backed by skylib.Query. A struct that can be used to search the cluster for instances of Services matching specified criteria. It's exposed for any custom need you may have for searching the cluster.</p>

<p>When the  cpu/memory/load monitoring is implemented Query will also be expanded to support searching based on this criteria.</p>

<pre>
type Query struct {
    Service    string
    Version    string
    Host       string
    Region     string
  Registered bool
    DoozerConn *DoozerConnection
}
</pre>

<p>The only required field here is a pointer to a doozer connection. All other fields are optional, any field not supplied will be considered as any/all. Keep in mind if you're going to make requests to an instance you'll want to ensure the Registered attribute is true, you don't want your code responsibile for sending requests to a server that's trying to shut down.</p>

<p>From here you can use any of the following</p>

<pre>
query.FindInstances()
</pre>

<p>Which will return a pointer to an array of Service pointers</p>

<pre>
// *[]*Service

// Refer to above for ServiceConfig structure
type Service struct {
    Config     *ServiceConfig
    Registered bool              `json:"-"`
}
</pre>

<p>If you feel like checking out the source some other things Query allow you to do:</p>

<pre>
query.FindHosts()
query.FindServices()
query.FindRegions()
query.ServiceVersions()
</pre>

<h2>Work In Progress</h2>

<h5>Process Monitoring / Restarting</h5>

<p>Services will restart themselves a specified number of times after crashing and add themselves back to the pool.</p>

<h5>Monitor CPU/Memory/Load</h5>

<p>Skynet will be aware of system utilization and number of requests going to specific instances of a service, and will be able to have a configurable threshold for it to restart or remove itself from the pool of instances for it's particular Service/Version, and return itself to the queue when the system has leveled out, or restart has completed</p>

<h5>Administration through sky command</h5>

<p>You will be able to register/unregister instances from skynet, stop, restart instances in your skynet cluster just by using the "sky" command with flags to filter instances (refer to the "sky" command section for more details on how these filters work"</p>

<h5>Time Series Data / Metrics</h5>

<p>We all love metrics and graphs, skynet will make sure you get your daily fix. More than likely we will utilize something like graphite to log time series data regarding number of requests, which calls are being made, response times, cpu/memory/load so that you can determine the state of your skynet cluster quickly with a dashboard of metrics.</p>

<p>After this functionality has been added we'd like to create a nice web interface to be hit and see live statistics going on across the system at that moment and refreshed live.</p>

<h5>Test Suite / Benchmarks / Refactoring / Docs</h5>

<p>Skynet has evolved quite a bit from the original idea/implementation, much experimentation and R&amp;D has been done to come up with the best approach, now that a lot of this has been finalized a full test suite will be coming, as well as some cleanup in areas of the codebase that were just quick prototypes to prove theories and need to be clean interfaces.</p>

<p>Also the addition of godocs, and other wiki pages to help better describe internals, and tips/tricks.</p>

<h5>Skylib for other languages</h5>

<p>Skylib is the core of skynet's internals and is how services/clients find each other, by implementing skylib in a variety of languages we will allow services and clients of many different languages to become a part of the skynet cluster.</p>

<h2>Communication</h2>

<ul>
<li>Group name: Skynet-dev</li>
<li>Group home page: <a href="http://groups.google.com/group/skynet-dev">http://groups.google.com/group/skynet-dev</a>
</li>
<li>Group email address <a href="mailto:skynet-dev@googlegroups.com">skynet-dev@googlegroups.com</a>
</li>
</ul><h2>Issues:</h2>

<p>Github Issues now the canonical source of issues for Skynet.</p>

<h2>Open Source - MIT Software License</h2>

<p>Copyright (c) 2012 Brian Ketelsen</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Skynet maintained by <a href="https://github.com/bketelsen">bketelsen</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
