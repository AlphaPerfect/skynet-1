{"google":"","body":"![logo](/bketelsen/skynet/raw/master/documentation/SkyNetLogo.png)\r\n\r\n##Introduction\r\nSkynet is a communication protocol for building massively distributed apps in Go.  It is not constrained to Go, so it will lend itself nicely to polyglot environments.\r\n\r\n##Tell me more:\r\nServers die, stop communicating, catch on fire, get killed by robots from the future, and should not be trusted. If your site won’t work with a Chaos Monkey, it isn’t safe. Enter Skynet. Each Skynet module is self–contained, self–aware, and self–replicating – if you have one server with an authentication module on it, and that server melts, Skynet will notice, kill it, and automatically create a new one. (if you let it)\r\n\r\nSkynet probably won’t die unless your data center gets hit by a comet.  We recommend at least 2 data centers in that scenario.\r\n\r\nSkynet Services are where the work gets done.  These are the processes that service the requests, process the API calls, get the external data, log the requests, authenticate the users, etc. \r\n\r\n\t\t\t\r\nBefore you can run skynet you'll need to have at least one [doozer](https://github.com/ha/doozerd) process running.  \r\n\r\n##How?\r\nEach process in SkyNet receives its configuration from a centralized configuration repository (currently Doozer - possibly pluggable in the future).  Configuration changes are pushed to each process when new skynet services are started.  This means that starting a new service automatically\r\nadvertises that service's availability to the rest of the members of the skynet cluster.\r\n\r\nSkyNet uses Doozer to store configuration data about the available services.  Configuration changes are pushed to Doozer, causing connected clients to immediately become aware of changed configurations.  \r\n\r\n##Running Processes\r\n* Sending SIGINT to a running process gracefully exits.\r\n\r\n######Work in Progress\r\n* Sending SIGUSR1 to a running process raises the log level one notch.\r\n* Sending SIGUSR2 to a running process lowers the log level one notch.\r\n\r\n## Doozer\r\nSkynet makes heavy usage of Doozer. Both clients and services will take a DoozerConfig so that it knows how to communicate with doozer. In the examples directory there is a shell script to startup a cluster of doozer instances locally for testing.\r\n\r\nWe recommend using at least 5 instances of doozer in your cluster, if you have 3, and lose 1, if an additonal doozer instance goes down the doozer cluster doesn't reject it.\r\n\r\n<pre>\r\ntype DoozerConfig struct {\r\n\tUri          string\r\n\tBootUri      string\r\n\tAutoDiscover bool\r\n}\r\n</pre>\r\n\r\n* Uri - ip/port of your doozer instance, this can be a comma separated list as well (doozer:8046, 127.0.0.1:8046)\r\n* BootUri - If you are using DzNs this is the ip/port of an instance of your boot cluster (doozer:8046, 127.0.0.1:8046)\r\n* AutoDiscover - true/false, Should this service or client discover other doozer instances in the doozer cluster, and use them for failback in case it looses it's current connection, as well as monitor any addition/removal from the doozer cluster\r\n\r\n##Services\r\nServices are the heart of your skynet clusters, they will accept requests via msgpack rpc requests. Keep in mind that a Service may also be a client. In the case of a Composite style application, a request could be made to one service that makes requests either synchronously or asynchronously to additional skynet services.\r\n\r\n#####Sweet! How do I create a service?\r\nProvided you have a doozer instance setup. It's pretty simple. Just create your service, with any methods you want exposed via rpc, and make sure it implements skylib.ServiceInterface\r\n\r\n<pre>\r\ntype ServiceInterface interface {\r\n\tStarted(s *Service)\r\n\tStopped(s *Service)\r\n\tRegistered(s *Service)\r\n\tUnregistered(s *Service)\r\n}\r\n</pre>\r\n\r\nThen call skylib.CreateService() passing it, a ServiceConfig, and and pointer to your custom service. Then call:\r\n\r\n<pre>\r\nservice.Start(true)\r\n</pre>\r\n\r\nThe boolean flag specifies whether the service should immediately register itself with the cluster.\r\n\r\n<pre>\r\ntype BindAddr struct {\r\n\tIPAddress string\r\n\tPort      int\r\n}\r\n\r\ntype ServiceConfig struct {\r\n\tLog         *log.Logger `json:\"-\"`\r\n\tName        string\r\n\tVersion     string\r\n\tRegion      string\r\n\tServiceAddr *BindAddr\r\n\tAdminAddr   *BindAddr\r\n\tDoozerConfig *DoozerConfig `json:\"-\"`\r\n}\r\n</pre>\r\n\r\nCheckout the examples/service directory for a full example, also a call to skylib.GetServiceConfigFromFlags() will, allow you to get all the config params from flags passed in via the command line.\r\n\r\n##Clients\r\nClients are just as simple. They start with a ClientConfig:\r\n\r\n#####Smart Connection Pools\r\nServiceClients's contain a pool of connections to a given service, up to a specified size to load balance requests across. Instances are removed from skynet when they crash, the pools are smart enough to remove any connections to any instances that are no longer available and replace them with connections to valid instances to maintain the pool.\r\n\r\n<pre>\r\ntype ClientConfig struct {\r\n\tLog         *log.Logger `json:\"-\"`\r\n\tDoozerConfig *DoozerConfig `json:\"-\"`\r\n}\r\n</pre>\r\n\r\nThen a call to:\r\n\r\n<pre>\r\nskylib.GetService(name string, version string, region string, host string) (*ServiceClient)\r\n</pre>\r\n\r\n* name - the name of the service you want to connect to, this is specified in your ServiceConfig\r\n* version - the version of the service, in case you have multiple versions up and running for backward compatibility, or you are in the middle of an upgrade / deploy\r\n* region - If you only want a connection(s) to instances of this service in a specific region (specified by the service) in case you want to keep a particular request in data center etc.\r\n* host - Similar to region, this restricts connections to only the specified host, an example might be if you only want to connect to the host the current client is on.\r\n\r\nAny empty values \"\", are considered to mean any/all instances matching the other supplied criteria.\r\n\r\nThis call returns a pointer to a ServiceClient, think of this as a connection pool, to instances of the service you requested, matching your criteria. It will always point contain connections to live instances, and readjust itself as the cluster changes, and recover from connection failures.\r\n\r\nFrom here just call your RPC method:\r\n\r\n<pre>\r\nserviceClient.Send(\"echo\", \"I'm connected!!\")\r\n</pre>\r\n\r\nCheckout the examples/client. directory for a full example.\r\n\r\n##Management\r\nThe \"sky\" command is your management gateway into the skynet cluster. It will allow you to probe the network and look for services/versions, hosts, regions etc in your cluster. As well as run administration commands to operate on instances that match the criteria (*admin commands are on the way, search functionality is here)\r\n\r\n<pre>\r\nUsage:\r\n\t sky -option1=value -option2=value command <arguments>\r\n\r\nCommands:\r\n\r\n\tcli: Interactive shell for executing commands against skynet cluster\r\n\thosts: List all hosts available that meet the specified criteria\r\n\t\t-service - limit results to hosts running the specified service\r\n\t\t-version - limit results to hosts running the specified version of the service (-service required)\r\n\t\t-region - limit results to hosts in the specified region\r\n\tinstances: List all instances available that meet the specified criteria\r\n\t\t-service - limit results to instances of the specified service\r\n\t\t-version - limit results to instances of the specified version of service\r\n\t\t-region - limit results to instances in the specified region\r\n\t\t-host - limit results to instances on the specified host\r\n\t\t-registered - (true, false) limit results to instances that are registered (accepting requests)\r\n\tregions: List all regions available that meet the specified criteria\r\n\tservices: List all services available that meet the specified criteria\r\n\t\t-host - limit results to the specified host\r\n\t\t-region - limit results to hosts in the specified region\r\n\r\n\tversions: List all services available that meet the specified criteria\r\n\t\t-service - service name (required)\r\n\t\t-host - limit results to the specified host\r\n\t\t-region - limit results to hosts in the specified region\r\n\r\n\ttopology: Print detailed heirarchy of regions/hosts/services/versions/instances\r\n\t\t-service - limit results to instances of the specified service\r\n\t\t-version - limit results to instances of the specified version of service\r\n\t\t-region - limit results to instances in the specified region\r\n\t\t-host - limit results to instances on the specified host\r\n</pre>\r\n\r\n####Interactive Shell\r\nAnother option is to use the interactive shell \"<b>sky cli</b>\". Which will open a shell you can interact with. Setting filters will allow any future commands to only apply to resources that meet those conditions.\r\n<pre>\r\nSkynet Interactive Shell\r\n> help\r\n\r\nCommands:\r\n\thosts: List all hosts available that meet the specified criteria\r\n\tinstances: List all instances available that meet the specified criteria\r\n\tregions: List all regions available that meet the specified criteria\r\n\tservices: List all services available that meet the specified criteria\r\n\tversions: List all services available that meet the specified criteria\r\n\ttopology: Print detailed heirarchy of regions/hosts/services/versions/instances\r\n\r\nFilters:\r\n\tfilters - list current filters\r\n\treset &lt;filter&gt; - reset all filters or specified filter\r\n\tregion &lt;region&gt; - Set region filter, all commands will be scoped to this region until reset\r\n\tservice &lt;service&gt; - Set service filter, all commands will be scoped to this service until reset\r\n\tversion &lt;version&gt; - Set version filter, all commands will be scoped to this version until reset\r\n\thost &lt;host&gt; - Set host filter, all commands will be scoped to this host until reset\r\n</pre>\r\n\r\n##Internals\r\n#####Query\r\nThe sky command and the client connectivity logic is all backed by skylib.Query. A struct that can be used to search the cluster for instances of Services matching specified criteria. It's exposed for any custom need you may have for searching the cluster.\r\n\r\nWhen the  cpu/memory/load monitoring is implemented Query will also be expanded to support searching based on this criteria.\r\n\r\n<pre>\r\ntype Query struct {\r\n\tService    string\r\n\tVersion    string\r\n\tHost       string\r\n\tRegion     string\r\n  Registered bool\r\n\tDoozerConn *DoozerConnection\r\n}\r\n</pre>\r\n\r\nThe only required field here is a pointer to a doozer connection. All other fields are optional, any field not supplied will be considered as any/all. Keep in mind if you're going to make requests to an instance you'll want to ensure the Registered attribute is true, you don't want your code responsibile for sending requests to a server that's trying to shut down.\r\n\r\nFrom here you can use any of the following\r\n\r\n<pre>\r\nquery.FindInstances()\r\n</pre>\r\n\r\nWhich will return a pointer to an array of Service pointers\r\n\r\n<pre>\r\n// *[]*Service\r\n\r\n// Refer to above for ServiceConfig structure\r\ntype Service struct {\r\n\tConfig     *ServiceConfig\r\n\tRegistered bool              `json:\"-\"`\r\n}\r\n</pre>\r\n\r\nIf you feel like checking out the source some other things Query allow you to do:\r\n<pre>\r\nquery.FindHosts()\r\nquery.FindServices()\r\nquery.FindRegions()\r\nquery.ServiceVersions()\r\n</pre>\r\n\r\n## Work In Progress\r\n#####Process Monitoring / Restarting\r\nServices will restart themselves a specified number of times after crashing and add themselves back to the pool.\r\n\r\n#####Monitor CPU/Memory/Load\r\nSkynet will be aware of system utilization and number of requests going to specific instances of a service, and will be able to have a configurable threshold for it to restart or remove itself from the pool of instances for it's particular Service/Version, and return itself to the queue when the system has leveled out, or restart has completed\r\n\r\n#####Administration through sky command\r\nYou will be able to register/unregister instances from skynet, stop, restart instances in your skynet cluster just by using the \"sky\" command with flags to filter instances (refer to the \"sky\" command section for more details on how these filters work\"\r\n\r\n#####Time Series Data / Metrics\r\nWe all love metrics and graphs, skynet will make sure you get your daily fix. More than likely we will utilize something like graphite to log time series data regarding number of requests, which calls are being made, response times, cpu/memory/load so that you can determine the state of your skynet cluster quickly with a dashboard of metrics.\r\n\r\nAfter this functionality has been added we'd like to create a nice web interface to be hit and see live statistics going on across the system at that moment and refreshed live.\r\n\r\n#####Test Suite / Benchmarks / Refactoring / Docs\r\nSkynet has evolved quite a bit from the original idea/implementation, much experimentation and R&D has been done to come up with the best approach, now that a lot of this has been finalized a full test suite will be coming, as well as some cleanup in areas of the codebase that were just quick prototypes to prove theories and need to be clean interfaces.\r\n\r\nAlso the addition of godocs, and other wiki pages to help better describe internals, and tips/tricks.\r\n\r\n#####Skylib for other languages\r\nSkylib is the core of skynet's internals and is how services/clients find each other, by implementing skylib in a variety of languages we will allow services and clients of many different languages to become a part of the skynet cluster.\r\n\r\n##Communication\r\n* Group name: Skynet-dev\r\n* Group home page: http://groups.google.com/group/skynet-dev\r\n* Group email address skynet-dev@googlegroups.com\r\n\r\n##Issues:\r\nGithub Issues now the canonical source of issues for Skynet.\r\n\r\n##Open Source - MIT Software License\r\nCopyright (c) 2012 Brian Ketelsen\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Skynet is a framework for distributed services in Go.","name":"Skynet"}